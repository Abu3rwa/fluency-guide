// src/services/student-services/studentAudioService.js
// Unified audio management service with priority-based fallbacks

import studentDictionaryApiService from "./studentDictionaryApiService";

class StudentAudioService {
  constructor() {
    this.dictionaryApi = studentDictionaryApiService;
    this.preferences = this.loadPreferences();
  }

  // Get best available audio URL for word
  async getAudioUrl(word, options = {}) {
    try {
      const sources = await this.getPriorityAudioSources(word, options);

      for (const source of sources) {
        if (await this.isAudioAvailable(source.audio)) {
          console.log(
            `‚úÖ Found available audio source: ${source.type} for word: ${word}`
          );
          return source;
        }
      }

      console.log(`‚ö†Ô∏è No audio sources available for word: ${word}`);
      return this.getFallbackAudio(word, options);
    } catch (error) {
      console.error("‚ùå Error getting audio URL:", error);
      return this.getFallbackAudio(word, options);
    }
  }

  // Get priority audio sources
  async getPriorityAudioSources(word, options = {}) {
    const sources = [];

    try {
      // 1. Dictionary API sources (highest priority)
      const dictionaryData = await this.dictionaryApi.fetchWordData(word);
      if (dictionaryData?.pronunciations) {
        const sortedUrls = this.sortByAccentPreference(
          dictionaryData.pronunciations,
          options.preferredAccent || this.preferences.accent
        );
        sources.push(...sortedUrls);
        console.log(
          `üîä Found ${sortedUrls.length} Dictionary API pronunciations for: ${word}`
        );
      }

      // 2. Existing static audio (medium priority)
      if (options.staticAudioUrl) {
        sources.push({
          text: `/${word}/`,
          audio: options.staticAudioUrl,
          type: "Static",
          source: "static",
          verified: false,
        });
        console.log(`üìÅ Added static audio source for: ${word}`);
      }

      // 3. TTS fallback (lowest priority)
      sources.push({
        text: `/${word}/`,
        audio: null, // Will be generated by TTS
        type: "TTS",
        source: "tts",
        verified: false,
      });

      console.log(`üìã Total audio sources for ${word}: ${sources.length}`);
      return sources;
    } catch (error) {
      console.error("‚ùå Error getting priority audio sources:", error);
      return this.getFallbackSources(word, options);
    }
  }

  // Sort pronunciations by user preference
  sortByAccentPreference(pronunciations, preferredAccent = "US") {
    const priority = {
      [preferredAccent.toUpperCase()]: 1,
      US: 2,
      UK: 3,
      AU: 4,
      Default: 5,
      "UK-Alt": 6,
    };

    return pronunciations.sort((a, b) => {
      const aPriority = priority[a.type] || 999;
      const bPriority = priority[b.type] || 999;
      return aPriority - bPriority;
    });
  }

  // Check if audio URL is available
  async isAudioAvailable(audioUrl) {
    if (!audioUrl) return false;

    try {
      const response = await fetch(audioUrl, { method: "HEAD" });
      return response.ok;
    } catch (error) {
      console.warn(`‚ö†Ô∏è Audio availability check failed for: ${audioUrl}`);
      return false;
    }
  }

  // Get fallback audio sources
  getFallbackSources(word, options = {}) {
    const sources = [];

    // Generate pattern-based URLs as fallback
    const patterns = [
      { suffix: "-us.mp3", type: "US" },
      { suffix: "-uk.mp3", type: "UK" },
      { suffix: "-au.mp3", type: "AU" },
    ];

    patterns.forEach((pattern) => {
      const audioUrl = `https://api.dictionaryapi.dev/media/pronunciations/en/${word}${pattern.suffix}`;
      sources.push({
        text: `/${word}/`,
        audio: audioUrl,
        type: pattern.type,
        source: "pattern",
        verified: false,
      });
    });

    // Add static audio if available
    if (options.staticAudioUrl) {
      sources.push({
        text: `/${word}/`,
        audio: options.staticAudioUrl,
        type: "Static",
        source: "static",
        verified: false,
      });
    }

    // Add TTS fallback
    sources.push({
      text: `/${word}/`,
      audio: null,
      type: "TTS",
      source: "tts",
      verified: false,
    });

    return sources;
  }

  // Get fallback audio
  getFallbackAudio(word, options) {
    return {
      text: `/${word}/`,
      audio: null,
      type: "TTS",
      source: "tts",
      verified: false,
    };
  }

  // Load user preferences
  loadPreferences() {
    try {
      const stored = localStorage.getItem("pronunciation_preferences");
      return stored
        ? JSON.parse(stored)
        : {
            preferredAccent: "US",
            autoPlay: false,
            playbackSpeed: 1.0,
            showPhonetics: true,
            cacheAudio: true,
          };
    } catch (error) {
      console.error("‚ùå Error loading preferences:", error);
      return {
        preferredAccent: "US",
        autoPlay: false,
        playbackSpeed: 1.0,
        showPhonetics: true,
        cacheAudio: true,
      };
    }
  }

  // Save user preferences
  savePreferences(preferences) {
    try {
      this.preferences = { ...this.preferences, ...preferences };
      localStorage.setItem(
        "pronunciation_preferences",
        JSON.stringify(this.preferences)
      );
      console.log("üíæ Saved pronunciation preferences");
    } catch (error) {
      console.error("‚ùå Error saving preferences:", error);
    }
  }

  // Update specific preference
  updatePreference(key, value) {
    this.preferences[key] = value;
    this.savePreferences({ [key]: value });
  }

  // Get current preferences
  getPreferences() {
    return { ...this.preferences };
  }

  // Preload audio for better UX
  async preloadAudio(urls) {
    if (!urls || urls.length === 0) return [];

    console.log(`üîÑ Preloading ${urls.length} audio files...`);

    const audioPromises = urls.map(async (pronunciation) => {
      if (!pronunciation.audio) return null;

      try {
        const audio = new Audio(pronunciation.audio);
        return new Promise((resolve) => {
          audio.oncanplaythrough = () => {
            console.log(`‚úÖ Preloaded audio: ${pronunciation.type}`);
            resolve(pronunciation);
          };
          audio.onerror = () => {
            console.warn(`‚ö†Ô∏è Failed to preload audio: ${pronunciation.type}`);
            resolve(null);
          };
        });
      } catch (error) {
        console.error("‚ùå Audio preload error:", error);
        return null;
      }
    });

    const results = await Promise.all(audioPromises);
    const successful = results.filter(Boolean);
    console.log(
      `‚úÖ Successfully preloaded ${successful.length}/${urls.length} audio files`
    );

    return successful;
  }

  // Play audio with error handling
  async playAudio(audioUrl, options = {}) {
    if (!audioUrl) {
      console.warn("‚ö†Ô∏è No audio URL provided");
      return false;
    }

    try {
      const audio = new Audio(audioUrl);

      if (options.playbackSpeed) {
        audio.playbackRate = options.playbackSpeed;
      }

      return new Promise((resolve, reject) => {
        audio.onended = () => {
          console.log("‚úÖ Audio playback completed");
          resolve(true);
        };

        audio.onerror = (error) => {
          console.error("‚ùå Audio playback error:", error);
          reject(new Error("Audio playback failed"));
        };

        audio.play().catch((error) => {
          console.error("‚ùå Audio play error:", error);
          reject(error);
        });
      });
    } catch (error) {
      console.error("‚ùå Audio play error:", error);
      return false;
    }
  }

  // Get audio source info
  getAudioSourceInfo(source) {
    return {
      type: source.type,
      source: source.source,
      verified: source.verified,
      text: source.text,
      hasAudio: !!source.audio,
    };
  }

  // Validate audio source
  validateAudioSource(source) {
    return {
      isValid: !!source && typeof source === "object",
      hasAudio: !!source?.audio,
      hasType: !!source?.type,
      hasText: !!source?.text,
    };
  }
}

export default new StudentAudioService();
